/**
 * Generate rules from existing learning data
 * Run this once to bootstrap rules from historical sessions
 */

import { getLearningAgent, LearningAgent } from '../services/learningSystem';
import * as fs from 'fs/promises';

interface LearningDB {
  sessions: any[];
  patterns: any[];
  rules: any[];
  stats: any;
}

async function generateRulesFromHistory() {
  console.log('=== RULE GENERATION FROM HISTORY ===\n');

  // Load the learning database directly
  const dbPath = './merlin-learning.json';
  const data = await fs.readFile(dbPath, 'utf-8');
  const db: LearningDB = JSON.parse(data);

  console.log(`Found ${db.sessions.length} sessions with ${db.rules.length} rules\n`);

  // Initialize the learning agent
  const agent = await getLearningAgent(dbPath);

  // Process each session that has issues
  const sessionsWithIssues = db.sessions.filter(s => s.issues && s.issues.length > 0);
  console.log(`Sessions with issues: ${sessionsWithIssues.length}\n`);

  const newRules: any[] = [];

  for (const session of sessionsWithIssues) {
    console.log(`\n--- Processing: ${session.domain} (Score: ${session.finalScore}%) ---`);
    console.log(`  Issues: ${session.issues.length}`);

    // Group issues by type
    const issuesByType = new Map<string, any[]>();
    for (const issue of session.issues) {
      const existing = issuesByType.get(issue.type) || [];
      existing.push(issue);
      issuesByType.set(issue.type, existing);
    }

    // Analyze broken_link issues
    const brokenLinkIssues = issuesByType.get('broken_link') || [];
    if (brokenLinkIssues.length >= 2) {
      const brokenPaths = new Set<string>();
      let needsMorePages = false;

      for (const issue of brokenLinkIssues) {
        const details = issue.context?.details || [];
        for (const detail of details) {
          const match = detail.match(/Broken: (.+)/);
          if (match) {
            brokenPaths.add(match[1]);
            if (match[1].includes('/login') || match[1].includes('/legal') ||
                match[1].includes('/faq') || match[1].includes('/demo') ||
                match[1].includes('/resource') || match[1].includes('/newsroom') ||
                match[1].includes('/partnerships') || match[1].includes('/media-assets')) {
              needsMorePages = true;
            }
          }
        }
      }

      if (needsMorePages || brokenPaths.size > 5) {
        const suggestedMaxPages = Math.max(30, Math.ceil(brokenPaths.size * 1.5) + session.pagesCloned);

        const rule = {
          id: `auto_broken_link_${session.domain.replace(/\./g, '_')}_${Date.now()}`,
          name: `Increase pages for ${session.domain}`,
          description: `${brokenPaths.size} broken links detected. Increase maxPages to capture more content.`,
          trigger: {
            type: 'domain_match',
            condition: session.domain
          },
          action: {
            type: 'url_transform',
            transform: 'increase_max_pages',
            params: {
              maxPages: suggestedMaxPages,
              brokenPathPatterns: Array.from(brokenPaths).slice(0, 20),
              reason: 'missing_pages'
            }
          },
          confidence: 75,
          timesApplied: 0,
          successCount: 0,
          failureCount: 0,
          enabled: true,
          autoGenerated: true,
          createdAt: Date.now(),
          lastUsed: Date.now()
        };

        console.log(`  ✓ Generated rule: "${rule.name}" (maxPages: ${suggestedMaxPages})`);
        newRules.push(rule);
      }
    }

    // Analyze font issues
    const otherIssues = issuesByType.get('other') || [];
    const fontIssue = otherIssues.find(i =>
      i.description?.includes('font') || i.context?.category === 'fonts'
    );

    if (fontIssue) {
      const rule = {
        id: `auto_font_${session.domain.replace(/\./g, '_')}_${Date.now()}`,
        name: `Font capture for ${session.domain}`,
        description: 'Site uses custom fonts that need explicit capture',
        trigger: {
          type: 'domain_match',
          condition: session.domain
        },
        action: {
          type: 'url_transform',
          transform: 'capture_fonts',
          params: {
            extractFromCSS: true,
            includeFontFaceRules: true,
            fontExtensions: ['.woff', '.woff2', '.ttf', '.otf', '.eot']
          }
        },
        confidence: 70,
        timesApplied: 0,
        successCount: 0,
        failureCount: 0,
        enabled: true,
        autoGenerated: true,
        createdAt: Date.now(),
        lastUsed: Date.now()
      };

      console.log(`  ✓ Generated rule: "${rule.name}"`);
      newRules.push(rule);
    }
  }

  // De-duplicate rules by domain (keep most recent)
  const rulesByDomain = new Map<string, any>();
  for (const rule of newRules) {
    const key = `${rule.trigger.condition}_${rule.action.transform}`;
    const existing = rulesByDomain.get(key);
    if (!existing || rule.createdAt > existing.createdAt) {
      rulesByDomain.set(key, rule);
    }
  }

  const uniqueRules = Array.from(rulesByDomain.values());

  console.log(`\n=== SUMMARY ===`);
  console.log(`Generated ${uniqueRules.length} unique rules:`);
  for (const rule of uniqueRules) {
    console.log(`  - ${rule.name}`);
    if (rule.action.params?.maxPages) {
      console.log(`    → maxPages: ${rule.action.params.maxPages}`);
    }
    if (rule.action.transform === 'capture_fonts') {
      console.log(`    → Enable font capture`);
    }
  }

  // Update the database
  db.rules = [...db.rules, ...uniqueRules];
  db.stats.rulesGenerated = db.rules.length;
  db.stats.patternsLearned = uniqueRules.length;

  // Save
  await fs.writeFile(dbPath, JSON.stringify(db, null, 2), 'utf-8');
  console.log(`\n✓ Database updated with ${uniqueRules.length} new rules`);

  // Test pre-clone analysis
  console.log('\n=== TESTING PRE-CLONE ANALYSIS ===\n');

  // Reload agent with new rules
  const testAgent = new (await import('../services/learningSystem')).LearningAgent(dbPath);
  await testAgent.initialize();

  for (const domain of ['www.osmo.supply', 'www.jeton.com']) {
    console.log(`\nPre-clone analysis for ${domain}:`);
    const analysis = await testAgent.preCloneAnalysis(`https://${domain}`);
    console.log(`  Confidence: ${analysis.confidence}%`);
    console.log(`  Applicable rules: ${analysis.applicableRules.length}`);
    console.log(`  Recommended settings:`, analysis.recommendedSettings);
    console.log(`  Predictions:`);
    for (const pred of analysis.predictedIssues) {
      console.log(`    - ${pred}`);
    }
  }

  await testAgent.shutdown();
}

generateRulesFromHistory().catch(console.error);
