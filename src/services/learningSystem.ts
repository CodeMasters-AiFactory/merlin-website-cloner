/**
 * MERLIN Learning System
 * Self-improving AI that learns from every clone operation
 *
 * Components:
 * - LearningAgent: Logs and analyzes clone outcomes
 * - PatternDatabase: Stores discovered patterns persistently
 * - RuleEngine: Generates and applies learned rules
 * - PreCloneAnalyzer: Predicts issues before cloning
 */

import * as fs from 'fs/promises';
import * as path from 'path';

// ============================================================================
// INTERFACES
// ============================================================================

export interface CloneIssue {
  id: string;
  type: 'broken_link' | 'missing_asset' | 'path_mismatch' | 'format_conversion' | 'dynamic_content' | 'anti_bot' | 'timeout' | 'protocol_timeout' | 'target_closed' | 'other';
  description: string;
  url: string;
  expectedPath?: string;
  actualPath?: string;
  context?: Record<string, unknown>;
  timestamp: number;
}

export interface CloneFix {
  issueId: string;
  fixType: 'url_normalization' | 'path_rewrite' | 'format_update' | 'retry' | 'skip' | 'manual';
  description: string;
  code?: string;
  successful: boolean;
}

export interface CloneSession {
  id: string;
  url: string;
  domain: string;
  startTime: number;
  endTime?: number;
  initialScore: number;
  finalScore: number;
  pagesCloned: number;
  assetsDownloaded: number;
  issues: CloneIssue[];
  fixes: CloneFix[];
  patterns: string[];  // Pattern IDs discovered
  rulesApplied: string[];  // Rule IDs that were applied
  metadata: {
    hasJavaScript: boolean;
    hasDynamicContent: boolean;
    cdnDomains: string[];
    techStack: string[];
  };
}

export interface LearnedPattern {
  id: string;
  type: 'url_pattern' | 'asset_pattern' | 'site_structure' | 'anti_bot' | 'cdn_behavior';
  pattern: string;
  regex?: string;
  description: string;
  frequency: number;
  successRate: number;
  domains: string[];
  examples: string[];
  createdAt: number;
  lastSeen: number;
}

export interface LearnedRule {
  id: string;
  name: string;
  description: string;
  trigger: {
    type: 'domain_match' | 'url_pattern' | 'tech_detection' | 'error_pattern';
    condition: string;
  };
  action: {
    type: 'url_transform' | 'path_rewrite' | 'add_header' | 'wait_longer' | 'skip_asset';
    transform: string;
    params?: Record<string, unknown>;
  };
  confidence: number;  // 0-100
  timesApplied: number;
  successCount: number;
  failureCount: number;
  enabled: boolean;
  autoGenerated: boolean;
  createdAt: number;
  lastUsed: number;
}

export interface LearningDatabase {
  version: string;
  sessions: CloneSession[];
  patterns: LearnedPattern[];
  rules: LearnedRule[];
  stats: {
    totalClones: number;
    successfulClones: number;
    averageScore: number;
    issuesFixed: number;
    patternsLearned: number;
    rulesGenerated: number;
  };
}

// ============================================================================
// PATTERN DATABASE
// ============================================================================

export class PatternDatabase {
  private dbPath: string;
  private db: LearningDatabase;
  private dirty: boolean = false;

  constructor(dbPath: string = './merlin-learning.json') {
    this.dbPath = dbPath;
    this.db = this.getDefaultDatabase();
  }

  private getDefaultDatabase(): LearningDatabase {
    return {
      version: '1.0.0',
      sessions: [],
      patterns: [],
      rules: [],
      stats: {
        totalClones: 0,
        successfulClones: 0,
        averageScore: 0,
        issuesFixed: 0,
        patternsLearned: 0,
        rulesGenerated: 0
      }
    };
  }

  async load(): Promise<void> {
    try {
      const data = await fs.readFile(this.dbPath, 'utf-8');
      this.db = JSON.parse(data);
      console.log(`[Learning] Loaded database: ${this.db.stats.totalClones} clones, ${this.db.patterns.length} patterns, ${this.db.rules.length} rules`);
    } catch (error) {
      // File doesn't exist, use default
      console.log('[Learning] No existing database, starting fresh');
      this.db = this.getDefaultDatabase();
    }
  }

  async save(): Promise<void> {
    if (!this.dirty) return;
    try {
      await fs.writeFile(this.dbPath, JSON.stringify(this.db, null, 2), 'utf-8');
      this.dirty = false;
      console.log('[Learning] Database saved');
    } catch (error) {
      console.error('[Learning] Failed to save database:', error);
    }
  }

  // Session management
  addSession(session: CloneSession): void {
    this.db.sessions.push(session);
    this.db.stats.totalClones++;
    if (session.finalScore >= 90) {
      this.db.stats.successfulClones++;
    }
    // Recalculate average
    const scores = this.db.sessions.map(s => s.finalScore);
    this.db.stats.averageScore = scores.reduce((a, b) => a + b, 0) / scores.length;
    this.dirty = true;
  }

  getSessionsByDomain(domain: string): CloneSession[] {
    return this.db.sessions.filter(s => s.domain === domain || s.domain.endsWith('.' + domain));
  }

  getRecentSessions(count: number = 10): CloneSession[] {
    return [...this.db.sessions]
      .sort((a, b) => b.startTime - a.startTime)
      .slice(0, count);
  }

  // Pattern management
  addPattern(pattern: LearnedPattern): void {
    const existing = this.db.patterns.find(p => p.id === pattern.id);
    if (existing) {
      existing.frequency++;
      existing.lastSeen = Date.now();
      existing.examples = [...new Set([...existing.examples, ...pattern.examples])].slice(0, 10);
    } else {
      this.db.patterns.push(pattern);
      this.db.stats.patternsLearned++;
    }
    this.dirty = true;
  }

  getPatternsByType(type: LearnedPattern['type']): LearnedPattern[] {
    return this.db.patterns.filter(p => p.type === type);
  }

  getPatternsByDomain(domain: string): LearnedPattern[] {
    return this.db.patterns.filter(p => p.domains.some(d => d === domain || d.endsWith('.' + domain)));
  }

  // Rule management
  addRule(rule: LearnedRule): void {
    const existing = this.db.rules.find(r => r.id === rule.id);
    if (existing) {
      // Update existing rule
      existing.confidence = rule.confidence;
      existing.lastUsed = Date.now();
    } else {
      this.db.rules.push(rule);
      this.db.stats.rulesGenerated++;
    }
    this.dirty = true;
  }

  getEnabledRules(): LearnedRule[] {
    return this.db.rules.filter(r => r.enabled);
  }

  getRulesByTrigger(type: LearnedRule['trigger']['type']): LearnedRule[] {
    return this.db.rules.filter(r => r.trigger.type === type && r.enabled);
  }

  updateRuleStats(ruleId: string, success: boolean): void {
    const rule = this.db.rules.find(r => r.id === ruleId);
    if (rule) {
      rule.timesApplied++;
      if (success) {
        rule.successCount++;
      } else {
        rule.failureCount++;
      }
      // Update confidence based on success rate
      rule.confidence = Math.round((rule.successCount / rule.timesApplied) * 100);
      // Disable rules with low confidence after enough attempts
      if (rule.timesApplied >= 10 && rule.confidence < 30) {
        rule.enabled = false;
        console.log(`[Learning] Disabled low-confidence rule: ${rule.name} (${rule.confidence}%)`);
      }
      this.dirty = true;
    }
  }

  getStats(): LearningDatabase['stats'] {
    return { ...this.db.stats };
  }

  getAllPatterns(): LearnedPattern[] {
    return [...this.db.patterns];
  }

  getAllRules(): LearnedRule[] {
    return [...this.db.rules];
  }
}

// ============================================================================
// RULE ENGINE
// ============================================================================

export class RuleEngine {
  private db: PatternDatabase;

  constructor(db: PatternDatabase) {
    this.db = db;
  }

  /**
   * Analyzes issues from a session and generates new rules
   */
  generateRulesFromIssues(session: CloneSession): LearnedRule[] {
    const newRules: LearnedRule[] = [];

    // Group issues by type
    const issuesByType = new Map<CloneIssue['type'], CloneIssue[]>();
    for (const issue of session.issues) {
      const existing = issuesByType.get(issue.type) || [];
      existing.push(issue);
      issuesByType.set(issue.type, existing);
    }

    // Generate rules for repeated issues
    for (const [type, issues] of issuesByType) {
      if (issues.length >= 2) {
        const rule = this.createRuleFromIssues(type, issues, session);
        if (rule) {
          newRules.push(rule);
        }
      }
    }

    // Look for URL patterns
    const urlPatterns = this.extractUrlPatterns(session.issues.map(i => i.url));
    for (const pattern of urlPatterns) {
      const existingPattern = this.db.getPatternsByType('url_pattern')
        .find(p => p.pattern === pattern.pattern);

      if (!existingPattern) {
        this.db.addPattern(pattern);
      }
    }

    return newRules;
  }

  private createRuleFromIssues(type: CloneIssue['type'], issues: CloneIssue[], session: CloneSession): LearnedRule | null {
    const ruleId = `auto_${type}_${session.domain.replace(/\./g, '_')}_${Date.now()}`;

    switch (type) {
      case 'broken_link': {
        // Analyze broken links to determine what pages need to be cloned
        const brokenPaths = new Set<string>();
        let needsMorePages = false;
        let needsExternalPages = false;

        for (const issue of issues) {
          // Extract broken path patterns from context
          const details = issue.context?.details as string[] || [];
          for (const detail of details) {
            const match = detail.match(/Broken: (.+)/);
            if (match) {
              const brokenPath = match[1];
              brokenPaths.add(brokenPath);

              // Check for patterns indicating we need more pages
              if (brokenPath.includes('/login') || brokenPath.includes('/legal') ||
                  brokenPath.includes('/faq') || brokenPath.includes('/demo') ||
                  brokenPath.includes('/resource') || brokenPath.includes('/newsroom') ||
                  brokenPath.includes('/partnerships') || brokenPath.includes('/media-assets')) {
                needsMorePages = true;
              }

              // Check for external/deeply nested paths
              if (brokenPath.startsWith('../../') || brokenPath.startsWith('../../../')) {
                needsExternalPages = true;
              }
            }
          }
        }

        // Calculate how many more pages we likely need
        const uniqueBrokenPaths = brokenPaths.size;
        const suggestedMaxPages = Math.max(20, Math.ceil(uniqueBrokenPaths * 1.5) + session.pagesCloned);

        if (needsMorePages || uniqueBrokenPaths > 5) {
          return {
            id: ruleId,
            name: `Increase pages for ${session.domain}`,
            description: `${uniqueBrokenPaths} broken links detected. Increase maxPages to capture more content.`,
            trigger: {
              type: 'domain_match',
              condition: session.domain
            },
            action: {
              type: 'url_transform',
              transform: 'increase_max_pages',
              params: {
                maxPages: suggestedMaxPages,
                brokenPathPatterns: Array.from(brokenPaths).slice(0, 20),
                reason: needsExternalPages ? 'deep_nesting' : 'missing_pages'
              }
            },
            confidence: 75,
            timesApplied: 0,
            successCount: 0,
            failureCount: 0,
            enabled: true,
            autoGenerated: true,
            createdAt: Date.now(),
            lastUsed: Date.now()
          };
        }
        break;
      }

      case 'path_mismatch': {
        // Find common path transformation pattern
        const transforms = issues
          .filter(i => i.expectedPath && i.actualPath)
          .map(i => ({
            from: i.expectedPath!,
            to: i.actualPath!
          }));

        if (transforms.length >= 2) {
          const pattern = this.findCommonTransform(transforms);
          if (pattern) {
            return {
              id: ruleId,
              name: `Path fix for ${session.domain}`,
              description: `Auto-generated rule to fix path mismatches on ${session.domain}`,
              trigger: {
                type: 'domain_match',
                condition: session.domain
              },
              action: {
                type: 'path_rewrite',
                transform: pattern.transform,
                params: pattern.params
              },
              confidence: 50,
              timesApplied: 0,
              successCount: 0,
              failureCount: 0,
              enabled: true,
              autoGenerated: true,
              createdAt: Date.now(),
              lastUsed: Date.now()
            };
          }
        }
        break;
      }

      case 'missing_asset': {
        // Check if assets are on CDN
        const cdnUrls = issues.filter(i => {
          try {
            const url = new URL(i.url);
            return url.hostname !== session.domain &&
                   (url.hostname.includes('cdn') ||
                    url.hostname.includes('assets') ||
                    url.hostname.includes('static'));
          } catch {
            return false;
          }
        });

        if (cdnUrls.length >= 2) {
          const cdnDomain = new URL(cdnUrls[0].url).hostname;
          return {
            id: ruleId,
            name: `CDN handling for ${session.domain}`,
            description: `Download assets from CDN: ${cdnDomain}`,
            trigger: {
              type: 'domain_match',
              condition: session.domain
            },
            action: {
              type: 'url_transform',
              transform: 'include_cdn',
              params: { cdnDomains: [cdnDomain] }
            },
            confidence: 60,
            timesApplied: 0,
            successCount: 0,
            failureCount: 0,
            enabled: true,
            autoGenerated: true,
            createdAt: Date.now(),
            lastUsed: Date.now()
          };
        }
        break;
      }

      case 'dynamic_content': {
        return {
          id: ruleId,
          name: `Extended wait for ${session.domain}`,
          description: 'Site has dynamic content, wait longer for JavaScript',
          trigger: {
            type: 'domain_match',
            condition: session.domain
          },
          action: {
            type: 'wait_longer',
            transform: 'extend_timeout',
            params: { waitMs: 5000, networkIdle: true }
          },
          confidence: 70,
          timesApplied: 0,
          successCount: 0,
          failureCount: 0,
          enabled: true,
          autoGenerated: true,
          createdAt: Date.now(),
          lastUsed: Date.now()
        };
      }

      case 'anti_bot': {
        return {
          id: ruleId,
          name: `Anti-bot bypass for ${session.domain}`,
          description: 'Site has anti-bot protection, use stealth mode',
          trigger: {
            type: 'domain_match',
            condition: session.domain
          },
          action: {
            type: 'add_header',
            transform: 'stealth_mode',
            params: {
              userAgent: 'real',
              delays: true,
              humanize: true
            }
          },
          confidence: 50,
          timesApplied: 0,
          successCount: 0,
          failureCount: 0,
          enabled: true,
          autoGenerated: true,
          createdAt: Date.now(),
          lastUsed: Date.now()
        };
      }

      case 'timeout': {
        // Find CDN domains that are timing out
        const timeoutDomains = new Set<string>();
        for (const issue of issues) {
          try {
            if (issue.url) {
              const url = new URL(issue.url);
              if (url.hostname.includes('cdn') || url.hostname.includes('b-cdn')) {
                timeoutDomains.add(url.hostname);
              }
            }
          } catch {}
        }

        if (timeoutDomains.size > 0) {
          return {
            id: ruleId,
            name: `CDN timeout handling for ${session.domain}`,
            description: `CDN domains timing out: ${Array.from(timeoutDomains).join(', ')}`,
            trigger: {
              type: 'domain_match',
              condition: session.domain
            },
            action: {
              type: 'wait_longer',
              transform: 'increase_cdn_timeout',
              params: {
                cdnDomains: Array.from(timeoutDomains),
                timeout: 60000,
                retries: 3
              }
            },
            confidence: 65,
            timesApplied: 0,
            successCount: 0,
            failureCount: 0,
            enabled: true,
            autoGenerated: true,
            createdAt: Date.now(),
            lastUsed: Date.now()
          };
        }
        break;
      }

      case 'protocol_timeout': {
        // Protocol timeouts are serious - usually means heavy JS site overwhelming browser
        // Common error: "Runtime.callFunctionOn timed out"
        // Solution: Increase protocolTimeout and reduce concurrency
        const errorMessages = issues.map(i => i.description).join(' ');
        const isRuntimeTimeout = errorMessages.includes('Runtime.callFunctionOn') ||
                                  errorMessages.includes('protocol');

        // Detect if it's a Next.js or heavy framework site
        const techStack = session.metadata.techStack || [];
        const isNextJs = techStack.includes('Next.js') || techStack.includes('nextjs');
        const isHeavyFramework = isNextJs ||
                                  techStack.includes('React') ||
                                  techStack.includes('Vue') ||
                                  techStack.includes('Angular');

        return {
          id: ruleId,
          name: `Protocol timeout fix for ${session.domain}`,
          description: `Heavy JS site causing protocol timeouts. ${isHeavyFramework ? 'Framework detected: ' + techStack.join(', ') : 'Reduce concurrency and increase timeout.'}`,
          trigger: {
            type: 'domain_match',
            condition: session.domain
          },
          action: {
            type: 'wait_longer',
            transform: 'increase_protocol_timeout',
            params: {
              protocolTimeout: 180000,  // 3 minutes (default is often 30s)
              concurrency: 2,  // Reduce from 5 to 2 for heavy sites
              pageTimeout: 90000,  // Longer page timeout
              isHeavyFramework,
              techStack: techStack.slice(0, 5)
            }
          },
          confidence: 80,  // High confidence - protocol timeouts are clear indicators
          timesApplied: 0,
          successCount: 0,
          failureCount: 0,
          enabled: true,
          autoGenerated: true,
          createdAt: Date.now(),
          lastUsed: Date.now()
        };
      }

      case 'target_closed': {
        // Target closed errors often cascade from protocol timeouts
        // Or happen when too many concurrent pages overwhelm the browser
        return {
          id: ruleId,
          name: `Stability fix for ${session.domain}`,
          description: `Browser sessions closing unexpectedly. Reduce concurrency and add recovery.`,
          trigger: {
            type: 'domain_match',
            condition: session.domain
          },
          action: {
            type: 'wait_longer',
            transform: 'improve_stability',
            params: {
              concurrency: 1,  // Go single-threaded for unstable sites
              retryOnClose: true,
              maxRetries: 3,
              delayBetweenPages: 2000  // 2 second delay between pages
            }
          },
          confidence: 70,
          timesApplied: 0,
          successCount: 0,
          failureCount: 0,
          enabled: true,
          autoGenerated: true,
          createdAt: Date.now(),
          lastUsed: Date.now()
        };
      }

      case 'other': {
        // Check for font-related issues
        const fontIssue = issues.find(i =>
          i.description.includes('font') ||
          (i.context?.category === 'fonts')
        );

        if (fontIssue) {
          return {
            id: ruleId,
            name: `Font capture for ${session.domain}`,
            description: 'Site uses custom fonts that need explicit capture',
            trigger: {
              type: 'domain_match',
              condition: session.domain
            },
            action: {
              type: 'url_transform',
              transform: 'capture_fonts',
              params: {
                extractFromCSS: true,
                includeFontFaceRules: true,
                fontExtensions: ['.woff', '.woff2', '.ttf', '.otf', '.eot']
              }
            },
            confidence: 70,
            timesApplied: 0,
            successCount: 0,
            failureCount: 0,
            enabled: true,
            autoGenerated: true,
            createdAt: Date.now(),
            lastUsed: Date.now()
          };
        }
        break;
      }
    }

    return null;
  }

  private findCommonTransform(transforms: { from: string; to: string }[]): { transform: string; params: Record<string, unknown> } | null {
    // Look for common patterns like:
    // - Adding /index.html suffix
    // - Removing query strings
    // - Format conversion (.jpg -> .webp)

    const indexHtmlCount = transforms.filter(t =>
      t.to.includes('/index.html') && !t.from.includes('/index.html')
    ).length;

    if (indexHtmlCount >= transforms.length * 0.5) {
      return {
        transform: 'add_index_html',
        params: {}
      };
    }

    const formatChangeCount = transforms.filter(t => {
      const fromExt = path.extname(t.from);
      const toExt = path.extname(t.to);
      return fromExt !== toExt && fromExt && toExt;
    }).length;

    if (formatChangeCount >= transforms.length * 0.5) {
      // Find most common format change
      const changes = transforms
        .filter(t => path.extname(t.from) !== path.extname(t.to))
        .map(t => ({ from: path.extname(t.from), to: path.extname(t.to) }));

      return {
        transform: 'format_conversion',
        params: { conversions: changes }
      };
    }

    return null;
  }

  private extractUrlPatterns(urls: string[]): LearnedPattern[] {
    const patterns: LearnedPattern[] = [];

    // Group URLs by domain
    const byDomain = new Map<string, string[]>();
    for (const urlStr of urls) {
      try {
        const url = new URL(urlStr);
        const existing = byDomain.get(url.hostname) || [];
        existing.push(url.pathname);
        byDomain.set(url.hostname, existing);
      } catch {
        // Skip invalid URLs
      }
    }

    // Find path patterns per domain
    for (const [domain, paths] of byDomain) {
      if (paths.length < 2) continue;

      // Look for common path prefixes
      const segments = paths.map(p => p.split('/').filter(Boolean));
      const commonPrefix = this.findCommonPrefix(segments);

      if (commonPrefix.length > 0) {
        const patternId = `url_${domain.replace(/\./g, '_')}_${commonPrefix.join('_')}`;
        patterns.push({
          id: patternId,
          type: 'url_pattern',
          pattern: `/${commonPrefix.join('/')}/*`,
          regex: `^/${commonPrefix.join('/')}/.+`,
          description: `URL pattern for ${domain}`,
          frequency: paths.length,
          successRate: 0,
          domains: [domain],
          examples: paths.slice(0, 5),
          createdAt: Date.now(),
          lastSeen: Date.now()
        });
      }
    }

    return patterns;
  }

  private findCommonPrefix(arrays: string[][]): string[] {
    if (arrays.length === 0) return [];
    if (arrays.length === 1) return arrays[0].slice(0, 1);

    const result: string[] = [];
    const minLength = Math.min(...arrays.map(a => a.length));

    for (let i = 0; i < minLength; i++) {
      const value = arrays[0][i];
      if (arrays.every(arr => arr[i] === value)) {
        result.push(value);
      } else {
        break;
      }
    }

    return result;
  }

  /**
   * Gets rules to apply for a given URL/domain
   */
  getRulesForUrl(url: string): LearnedRule[] {
    const rules: LearnedRule[] = [];

    try {
      const urlObj = new URL(url);
      const domain = urlObj.hostname;

      // Get domain-specific rules
      const domainRules = this.db.getRulesByTrigger('domain_match')
        .filter(r => r.trigger.condition === domain || domain.endsWith('.' + r.trigger.condition));
      rules.push(...domainRules);

      // Get URL pattern rules
      const patternRules = this.db.getRulesByTrigger('url_pattern')
        .filter(r => {
          try {
            const regex = new RegExp(r.trigger.condition);
            return regex.test(url);
          } catch {
            return false;
          }
        });
      rules.push(...patternRules);

    } catch {
      // Invalid URL
    }

    // Sort by confidence
    return rules.sort((a, b) => b.confidence - a.confidence);
  }

  /**
   * Applies a rule and returns the transformed value
   */
  applyRule(rule: LearnedRule, input: string): string {
    switch (rule.action.type) {
      case 'url_transform':
        return this.applyUrlTransform(rule, input);
      case 'path_rewrite':
        return this.applyPathRewrite(rule, input);
      default:
        return input;
    }
  }

  private applyUrlTransform(rule: LearnedRule, url: string): string {
    switch (rule.action.transform) {
      case 'include_cdn':
        // CDN URLs should be downloaded
        return url;
      default:
        return url;
    }
  }

  private applyPathRewrite(rule: LearnedRule, path: string): string {
    switch (rule.action.transform) {
      case 'add_index_html':
        if (!path.endsWith('/index.html') && !path.includes('.')) {
          return path.replace(/\/?$/, '/index.html');
        }
        return path;
      case 'format_conversion':
        // Would need actual format info
        return path;
      default:
        return path;
    }
  }
}

// ============================================================================
// PRE-CLONE ANALYZER
// ============================================================================

export class PreCloneAnalyzer {
  private db: PatternDatabase;
  private ruleEngine: RuleEngine;

  constructor(db: PatternDatabase, ruleEngine: RuleEngine) {
    this.db = db;
    this.ruleEngine = ruleEngine;
  }

  /**
   * Analyzes a URL before cloning to predict issues and recommend settings
   */
  async analyze(url: string): Promise<{
    predictedIssues: string[];
    recommendedSettings: Record<string, unknown>;
    applicableRules: LearnedRule[];
    similarSites: CloneSession[];
    confidence: number;
  }> {
    const predictions: string[] = [];
    const settings: Record<string, unknown> = {};

    try {
      const urlObj = new URL(url);
      const domain = urlObj.hostname;

      // Get historical data for this domain
      const previousSessions = this.db.getSessionsByDomain(domain);
      const applicableRules = this.ruleEngine.getRulesForUrl(url);

      // Analyze previous sessions for this domain
      if (previousSessions.length > 0) {
        const avgScore = previousSessions.reduce((sum, s) => sum + s.finalScore, 0) / previousSessions.length;
        const commonIssues = this.findCommonIssues(previousSessions);

        if (avgScore < 80) {
          predictions.push(`Historical average score: ${avgScore.toFixed(0)}% - expect issues`);
        }

        for (const issue of commonIssues) {
          predictions.push(`Common issue: ${issue.type} (${issue.count} times)`);
        }

        // Apply settings from successful clones
        const successful = previousSessions.filter(s => s.finalScore >= 90);
        if (successful.length > 0) {
          const best = successful.sort((a, b) => b.finalScore - a.finalScore)[0];
          settings.maxPages = best.pagesCloned;
          if (best.metadata.hasJavaScript) {
            settings.javascript = true;
            settings.waitForDynamic = true;
          }
        }
      }

      // Apply rules - THIS IS WHERE LEARNING ACTUALLY HAPPENS
      for (const rule of applicableRules) {
        if (rule.action.type === 'wait_longer') {
          settings.waitForDynamic = true;
          settings.timeout = Math.max((settings.timeout as number) || 60000, 90000);
          predictions.push(`Rule "${rule.name}": Extended timeout recommended`);
        }
        if (rule.action.type === 'add_header' && rule.action.transform === 'stealth_mode') {
          settings.respectRobots = false;
          predictions.push(`Rule "${rule.name}": Stealth mode recommended`);
        }
        if (rule.action.params?.cdnDomains) {
          settings.allowedDomains = rule.action.params.cdnDomains;
          predictions.push(`Rule "${rule.name}": Include CDN domains`);
        }

        // Handle broken_link rules - increase maxPages
        if (rule.action.transform === 'increase_max_pages') {
          const suggestedPages = rule.action.params?.maxPages as number || 30;
          settings.maxPages = Math.max((settings.maxPages as number) || 10, suggestedPages);
          predictions.push(`ðŸ§  LEARNED: "${rule.name}" - Set maxPages to ${settings.maxPages}`);
        }

        // Handle font capture rules
        if (rule.action.transform === 'capture_fonts') {
          settings.captureFonts = true;
          settings.fontExtensions = rule.action.params?.fontExtensions;
          predictions.push(`ðŸ§  LEARNED: "${rule.name}" - Enable font capture`);
        }

        // Handle CDN timeout rules
        if (rule.action.transform === 'increase_cdn_timeout') {
          settings.cdnTimeout = rule.action.params?.timeout || 60000;
          settings.cdnRetries = rule.action.params?.retries || 3;
          settings.cdnDomains = rule.action.params?.cdnDomains;
          predictions.push(`ðŸ§  LEARNED: "${rule.name}" - Increase CDN timeout`);
        }

        // Handle protocol timeout rules (heavy JS sites)
        if (rule.action.transform === 'increase_protocol_timeout') {
          settings.protocolTimeout = rule.action.params?.protocolTimeout || 180000;
          settings.concurrency = Math.min(
            (settings.concurrency as number) || 5,
            rule.action.params?.concurrency as number || 2
          );
          settings.pageTimeout = rule.action.params?.pageTimeout || 90000;
          settings.isHeavyFramework = rule.action.params?.isHeavyFramework;
          predictions.push(`ðŸ§  LEARNED: "${rule.name}" - Reduce concurrency to ${settings.concurrency}, protocolTimeout to ${settings.protocolTimeout}ms`);
        }

        // Handle stability rules (target closed errors)
        if (rule.action.transform === 'improve_stability') {
          settings.concurrency = Math.min(
            (settings.concurrency as number) || 5,
            rule.action.params?.concurrency as number || 1
          );
          settings.retryOnClose = rule.action.params?.retryOnClose;
          settings.maxRetries = rule.action.params?.maxRetries || 3;
          settings.delayBetweenPages = rule.action.params?.delayBetweenPages || 2000;
          predictions.push(`ðŸ§  LEARNED: "${rule.name}" - Single-threaded mode with ${settings.delayBetweenPages}ms delay`);
        }
      }

      // Look for similar sites (same TLD, similar structure)
      const similarSites = this.findSimilarSites(domain);

      // Calculate confidence based on data available
      let confidence = 30; // Base confidence
      if (previousSessions.length > 0) confidence += 30;
      if (previousSessions.length > 5) confidence += 20;
      if (applicableRules.length > 0) confidence += 10;
      if (similarSites.length > 0) confidence += 10;

      return {
        predictedIssues: predictions,
        recommendedSettings: settings,
        applicableRules,
        similarSites: similarSites.slice(0, 5),
        confidence: Math.min(confidence, 100)
      };

    } catch (error) {
      return {
        predictedIssues: ['Failed to analyze URL'],
        recommendedSettings: {},
        applicableRules: [],
        similarSites: [],
        confidence: 0
      };
    }
  }

  private findCommonIssues(sessions: CloneSession[]): { type: string; count: number }[] {
    const issueCounts = new Map<string, number>();

    for (const session of sessions) {
      for (const issue of session.issues) {
        const count = issueCounts.get(issue.type) || 0;
        issueCounts.set(issue.type, count + 1);
      }
    }

    return Array.from(issueCounts.entries())
      .map(([type, count]) => ({ type, count }))
      .sort((a, b) => b.count - a.count)
      .slice(0, 5);
  }

  private findSimilarSites(domain: string): CloneSession[] {
    // Find sites with similar TLD or structure
    const tld = domain.split('.').slice(-1)[0];
    const allSessions = this.db.getRecentSessions(100);

    return allSessions.filter(s => {
      const sessionTld = s.domain.split('.').slice(-1)[0];
      return sessionTld === tld && s.domain !== domain;
    });
  }
}

// ============================================================================
// LEARNING AGENT (Main Class)
// ============================================================================

export class LearningAgent {
  private db: PatternDatabase;
  private ruleEngine: RuleEngine;
  private preAnalyzer: PreCloneAnalyzer;
  private currentSession: CloneSession | null = null;

  constructor(dbPath: string = './merlin-learning.json') {
    this.db = new PatternDatabase(dbPath);
    this.ruleEngine = new RuleEngine(this.db);
    this.preAnalyzer = new PreCloneAnalyzer(this.db, this.ruleEngine);
  }

  async initialize(): Promise<void> {
    await this.db.load();
    console.log('[Learning Agent] Initialized');
    console.log(`[Learning Agent] Stats: ${JSON.stringify(this.db.getStats())}`);
  }

  async shutdown(): Promise<void> {
    await this.db.save();
    console.log('[Learning Agent] Shutdown complete');
  }

  /**
   * Called before cloning to get predictions and recommendations
   */
  async preCloneAnalysis(url: string): Promise<{
    predictedIssues: string[];
    recommendedSettings: Record<string, unknown>;
    applicableRules: LearnedRule[];
    confidence: number;
  }> {
    const analysis = await this.preAnalyzer.analyze(url);

    console.log(`[Learning Agent] Pre-clone analysis for ${url}:`);
    console.log(`  Confidence: ${analysis.confidence}%`);
    console.log(`  Predicted issues: ${analysis.predictedIssues.length}`);
    console.log(`  Applicable rules: ${analysis.applicableRules.length}`);

    return {
      predictedIssues: analysis.predictedIssues,
      recommendedSettings: analysis.recommendedSettings,
      applicableRules: analysis.applicableRules,
      confidence: analysis.confidence
    };
  }

  /**
   * Starts a new clone session for logging
   */
  startSession(url: string): string {
    const urlObj = new URL(url);
    const sessionId = `session_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`;

    this.currentSession = {
      id: sessionId,
      url,
      domain: urlObj.hostname,
      startTime: Date.now(),
      initialScore: 0,
      finalScore: 0,
      pagesCloned: 0,
      assetsDownloaded: 0,
      issues: [],
      fixes: [],
      patterns: [],
      rulesApplied: [],
      metadata: {
        hasJavaScript: false,
        hasDynamicContent: false,
        cdnDomains: [],
        techStack: []
      }
    };

    console.log(`[Learning Agent] Started session: ${sessionId}`);
    return sessionId;
  }

  /**
   * Logs an issue during cloning
   */
  logIssue(issue: Omit<CloneIssue, 'id' | 'timestamp'>): string {
    if (!this.currentSession) {
      console.warn('[Learning Agent] No active session');
      return '';
    }

    const issueId = `issue_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`;
    const fullIssue: CloneIssue = {
      ...issue,
      id: issueId,
      timestamp: Date.now()
    };

    this.currentSession.issues.push(fullIssue);
    console.log(`[Learning Agent] Logged issue: ${issue.type} - ${issue.description}`);

    return issueId;
  }

  /**
   * Logs a fix that was applied
   */
  logFix(fix: Omit<CloneFix, 'issueId'>, issueId?: string): void {
    if (!this.currentSession) {
      console.warn('[Learning Agent] No active session');
      return;
    }

    const fullFix: CloneFix = {
      ...fix,
      issueId: issueId || ''
    };

    this.currentSession.fixes.push(fullFix);

    if (fix.successful) {
      this.db.getStats().issuesFixed++;
    }
  }

  /**
   * Updates session metadata
   */
  updateMetadata(metadata: Partial<CloneSession['metadata']>): void {
    if (!this.currentSession) return;
    this.currentSession.metadata = {
      ...this.currentSession.metadata,
      ...metadata
    };
  }

  /**
   * Updates clone progress
   */
  updateProgress(pagesCloned: number, assetsDownloaded: number): void {
    if (!this.currentSession) return;
    this.currentSession.pagesCloned = pagesCloned;
    this.currentSession.assetsDownloaded = assetsDownloaded;
  }

  /**
   * Ends the session and triggers learning
   */
  async endSession(finalScore: number): Promise<{
    newRules: LearnedRule[];
    newPatterns: LearnedPattern[];
    improvement: number;
  }> {
    if (!this.currentSession) {
      return { newRules: [], newPatterns: [], improvement: 0 };
    }

    this.currentSession.endTime = Date.now();
    this.currentSession.finalScore = finalScore;

    // Calculate improvement over previous attempts on same domain
    const previousSessions = this.db.getSessionsByDomain(this.currentSession.domain);
    const previousAvg = previousSessions.length > 0
      ? previousSessions.reduce((sum, s) => sum + s.finalScore, 0) / previousSessions.length
      : 0;
    const improvement = finalScore - previousAvg;

    // Generate new rules from issues
    const newRules = this.ruleEngine.generateRulesFromIssues(this.currentSession);
    for (const rule of newRules) {
      this.db.addRule(rule);
    }

    // Save session
    this.db.addSession(this.currentSession);
    await this.db.save();

    console.log(`[Learning Agent] Session ended:`);
    console.log(`  Final score: ${finalScore}%`);
    console.log(`  Issues logged: ${this.currentSession.issues.length}`);
    console.log(`  Fixes applied: ${this.currentSession.fixes.length}`);
    console.log(`  New rules generated: ${newRules.length}`);
    console.log(`  Improvement over previous: ${improvement > 0 ? '+' : ''}${improvement.toFixed(1)}%`);

    const result = {
      newRules,
      newPatterns: [], // Patterns are added during rule generation
      improvement
    };

    this.currentSession = null;
    return result;
  }

  /**
   * Gets learning statistics
   */
  getStats(): LearningDatabase['stats'] {
    return this.db.getStats();
  }

  /**
   * Gets all learned rules
   */
  getRules(): LearnedRule[] {
    return this.db.getAllRules();
  }

  /**
   * Gets all learned patterns
   */
  getPatterns(): LearnedPattern[] {
    return this.db.getAllPatterns();
  }

  /**
   * Manually adds a rule (for known issues)
   */
  addManualRule(rule: Omit<LearnedRule, 'id' | 'createdAt' | 'lastUsed' | 'autoGenerated'>): void {
    const fullRule: LearnedRule = {
      ...rule,
      id: `manual_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`,
      autoGenerated: false,
      createdAt: Date.now(),
      lastUsed: Date.now()
    };
    this.db.addRule(fullRule);
  }

  /**
   * Exports learning data for backup
   */
  async exportLearning(): Promise<string> {
    return JSON.stringify({
      patterns: this.db.getAllPatterns(),
      rules: this.db.getAllRules(),
      stats: this.db.getStats(),
      exportedAt: Date.now()
    }, null, 2);
  }

  /**
   * Gets a summary report of learning
   */
  getSummaryReport(): string {
    const stats = this.db.getStats();
    const rules = this.db.getAllRules();
    const patterns = this.db.getAllPatterns();

    const enabledRules = rules.filter(r => r.enabled);
    const autoRules = rules.filter(r => r.autoGenerated);
    const highConfidenceRules = rules.filter(r => r.confidence >= 70);

    return `
=== MERLIN LEARNING REPORT ===

ðŸ“Š Statistics:
  Total clones: ${stats.totalClones}
  Successful clones (90%+): ${stats.successfulClones}
  Average score: ${stats.averageScore.toFixed(1)}%
  Issues fixed: ${stats.issuesFixed}

ðŸ§  Rules:
  Total rules: ${rules.length}
  Enabled: ${enabledRules.length}
  Auto-generated: ${autoRules.length}
  High confidence (70%+): ${highConfidenceRules.length}

ðŸ” Patterns:
  URL patterns: ${patterns.filter(p => p.type === 'url_pattern').length}
  Asset patterns: ${patterns.filter(p => p.type === 'asset_pattern').length}
  Site structures: ${patterns.filter(p => p.type === 'site_structure').length}

ðŸ“ˆ Top Rules by Success:
${highConfidenceRules.slice(0, 5).map(r =>
  `  - ${r.name}: ${r.confidence}% (${r.timesApplied} uses)`
).join('\n') || '  (none yet)'}

================================
`.trim();
  }
}

// Export singleton for easy use
let _learningAgent: LearningAgent | null = null;

export async function getLearningAgent(dbPath?: string): Promise<LearningAgent> {
  if (!_learningAgent) {
    _learningAgent = new LearningAgent(dbPath);
    await _learningAgent.initialize();
  }
  return _learningAgent;
}

export async function shutdownLearningAgent(): Promise<void> {
  if (_learningAgent) {
    await _learningAgent.shutdown();
    _learningAgent = null;
  }
}
